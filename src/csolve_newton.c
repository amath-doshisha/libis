#include<stdio.h>#include<stdlib.h>#include<isys.h>#define FLT_EPSILON         1.19209290E-07F#define DBL_EPSILON         2.2204460492503131E-16#define LDBL_EPSILON        1.084202172485504434e-019L#define RMA(A,M,N) { A=rmat_allocate(M,N); }#define RMF(A,M,N) { A=rmat_free(M,N,A); }#define RVA(X,N)   { X=rvec_allocate(N); }#define RVF(X,N)   { X=rvec_free(N,X); }#define IVA(X,N)   { X=ivec_allocate(N); }#define IVF(X)     { X=ivec_free(X); }#define RA(X)      { X=rallocate(); }#define RF(X)      { X=rfree(X); }#define CMA(A,M,N) { A=cmat_allocate(M,N); }#define CMF(A,M,N) { A=cmat_free(M,N,A); }#define CMR(M,N,A,LDA,B) { cmat_round((M),(N),(A),(LDA),(B)); }#define CVA(X,N)   { X=cvec_allocate(N); }#define CVF(X,N)   { X=cvec_free(N,X); }#define CVR(N,X,B) { cvec_round_cvec((N),(X),(B)); }#define CA(X)      { X=callocate(); }#define CF(X)      { X=cfree(X); }#define RR(X,B)    { rround((X),(B)); }///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Input: m,x,fF,nmax// Output: xint csolve_newton_adjust(int m, cmulti **x, func_t *fF, cmulti **xt, rmulti *eps, int nmax, double mu_start, int l, int kappa, int debug){  char *name="csolve_newton_adap",status=' ';  int kappa_gain=26;  int info=0,t=0,n=0,n0=0,n1=0,n2=0,ret=0,nofit=1,k=0,kmax=4,gamma_exp=-1;  int prec=-1,bmax=30000,*b=NULL,*tau=NULL;  func_t *fJ=NULL;  cmulti **F=NULL,**y=NULL,**dx=NULL,**J=NULL,**X=NULL;  rmulti *theta_min=NULL;  rmulti **eta=NULL,**mu=NULL,**beta=NULL,**theta=NULL,**theta0=NULL;  rmulti **F_norm=NULL,**x_norm=NULL,**Ek=NULL,**Et=NULL,**eb=NULL,**em=NULL,**e=NULL,**c=NULL;  // backup default prec  prec=get_default_prec();  // check step max  if(nmax<0){ nmax=100; }  // allocate  IVA(b,nmax); IVA(tau,nmax);  CVA(F,m); CVA(y,m); CVA(dx,m); CMA(J,m,m); CMA(X,m,kmax);  RA(theta_min);  RVA(eta,nmax); RVA(mu,nmax); RVA(beta,nmax); RVA(theta,nmax); RVA(theta0,nmax);  RVA(F_norm,nmax); RVA(x_norm,nmax); RVA(Ek,nmax); RVA(Et,nmax); RVA(eb,nmax); RVA(em,nmax); RVA(e,nmax); RVA(c,nmax);  // set starting prec  ivec_set_all(nmax,b,prec);  // Jacobi matrix  fJ=func_grad(func_retain(fF),func_var1_list(m));  // debug  if(debug>0){    mpfr_printf("[%s] nmax=%d\n",name,nmax);    mpfr_printf("[%s] eps=%.2Re\n",name,eps);    printf("[%s] mu_start=%.2e\n",name,mu_start);    printf("[%s] l=%d\n",name,l);    printf("[%s] kappa=%d\n",name,kappa);    printf("[%s] F(x)=",name); func_print(fF); printf("\n");    printf("[%s] F'(x)=",name); func_print(fJ); printf("\n");  }  // set theta  rset_d(theta_min,1);  // set initial vector  n=0;  if(cvec_has_nan(m,x)){ cvec_set_rand(m,x,2,-1); }  if(debug>0){ mpfr_printf("[%s] begin with x%d\n",name,n,n); }  // compute  do{    // tau=exponent(x)    tau[n]=cvec_get_exp_max(m,x);    // estimate theta    if(n>=2 && ris_number(beta[n-2])){ csolve_newton_theta_estimate(theta0[n-1],theta_min); }    else if(n>=1){ rset_nan(theta0[n-1]); }    // set precision    if(n>=2 && ris_number(beta[n-2])){      csolve_newton_beta_by_recur(3,&beta[n-2]);      b[n]=csolve_newton_prec_from_beta(eta[n-1],beta[n-1],beta[n],theta0[n-1],gamma_exp,kappa,tau[n]);    }else if(n>=2){      b[n]=csolve_newton_prec_from_eta(eta[n-2],eta[n-1],gamma_exp,kappa,tau[n]);    }    if(n>=1 && b[n]<=b[n-1]){ b[n]=b[n-1]; }    // rounding with prec    set_default_prec(b[n]);    CVR(m,F,b[n]); CVR(m,x,b[n]); CVR(m,y,b[n]); CVR(m,dx,b[n]); CMR(m,m,J,m,b[n]);    RR(theta_min,b[n]); RR(eta[n],b[n]); RR(F_norm[n],b[n]); RR(x_norm[n],b[n]);    RR(Ek[n],b[n]); RR(Et[n],b[n]); RR(eb[n],b[n]); RR(em[n],b[n]); RR(e[n],b[n]); RR(c[n],b[n]);    if(n>=1){ RR(mu[n-1],b[n]); RR(beta[n-1],b[n]); RR(theta[n-1],b[n]); RR(theta0[n-1],b[n]); }    // x_norm=|x|    rmax_abs_cvec(x_norm[n],m,x);    // F=F(x)    cvec_func_list(m,F,fF,m,x);    // F_norm=|F|    rmax_abs_cvec(F_norm[n],m,F);    if(eq_rd(F_norm[n],0)){ csolve_func_residual(m,F_norm[n],F,x,fF); }    // if exactly F=0    if(eq_rd(F_norm[n],0)){      status='=';      rset_d(eta[n],0);      if(n>=1){ rset_inf(mu[n-1],1); rset_nan(beta[n-1]); rset_nan(theta[n-1]); }    }else{      // if not exactly F=0      // J=J(x)      cmat_func_list2(m,m,J,m,fJ,m,x);      // F=J\F      csolve(m,1,F,m,J,m,&info);      if(debug>1){ cvec_clone_cvec(m,dx,F); }      // if J is singular      if(info){	status='J';	rset_nan(eta[n]);	if(n>=1){ rset_nan(mu[n-1]); rset_nan(beta[n-1]); rset_nan(theta[n-1]); }      }else{	// if J is not singular	// y=x-J\F	cvec_sub_cvec_cvec(m,y,x,F);	// eta=max(abs(y-x))	rmax_abs_sub_cvec_cvec(eta[n],m,y,x);	// mu=eta/(2*eta)	if(n>=1){ rdiv_rr(mu[n-1],eta[n-1],eta[n]); rdiv_2exp(mu[n-1],mu[n-1],1); }      }    }    // set beta    if(status==' ' && n>=l && ris_number(mu[n-l]) && ge_rd(mu[n-l],mu_start)){      // set as quadratic convergence      nofit=csolve_newton_beta_from_mu(l,&beta[n-l],&mu[n-l],debug-2);      if(!nofit){	// set theta	csolve_newton_theta(l,&theta[n-l],theta_min,&mu[n-l],&beta[n-l]);	// set gamma	gamma_exp=csolve_newton_gamma(beta[n-1],mu[n-1]);      }    }else if(n>=2 && ris_number(beta[n-2]) && !ris_number(beta[n-1])){      // set by recursion      nofit=1; csolve_newton_beta_by_recur(2,&beta[n-2]);    }else if(n>=1 && ris_number(beta[n-1])){      // keep      nofit=1;    }else if(n>=1){      // reset      nofit=1; rset_nan(beta[n-1]);    }    // set theta    if(n>=1 && ris_number(mu[n-1]) && ris_number(beta[n-1])){ csolve_newton_theta(1,&theta[n-1],theta_min,&mu[n-1],&beta[n-1]); }    else if(status=='='){ rset_d(theta[n-1],0); }    else if(n>=1){ rset_nan(theta[n-1]); }    // set status    if     (status==' ' && n>=1 && ris_number(beta[n-1])){ status='o'; n0=n-l; n1=n; } // starting    else if((status=='o' || status=='^') && n>=1 && !csolve_newton_condition_conv(m,&COL(X,0,m),x,y,beta[n-1])){ status='x'; } // not satisfy    else if((status=='x' || status=='^') && n>=1 &&  csolve_newton_condition_conv(m,&COL(X,0,m),x,y,beta[n-1])){ status='o'; } // satisfy    if(status=='o' && n>=1 && ris_number(beta[n-1]) && ris_number(theta[n-1]) && ris_number(theta0[n-1]) && gt_rr(theta0[n-1],theta[n-1])){ status='^';  }    if     (status=='=')                    { status='='; }    else if(status=='J')                    { status='J'; }    else if(status=='o' && csolve_newton_condition_done(m,x,y,eps)){ status='.';  } // succeeded if 2*eta_{n}<=eps    else if(status=='o' && b[n]>bmax)       { status=','; }    else if(status=='o' && n>=nmax-1)       { status=';';  }    else if(n>=nmax-1)                      { status='N';  }    else if(b[n]>bmax)                      { status='P'; }    // debug    if(debug>0){      if     (status=='x')                              { print_light_red(); }      else if(status=='^')                              { print_purple(); }      else if(status=='=' || status==',' || status==';'){ print_brown(); }      else if(status=='J' || status=='N' || status=='P'){ print_red(); }      else if(status=='o' && n-n2<=-3){ print_cyan(); }      else if(status=='o' && n-n2<=-2){ print_yellow(); }      else if(status=='o' && n-n2<=-1){ print_green(); }      mpfr_printf("[%s:%03d:%2d] n=%3d [%c] κ=%d b=%5d ",name,t,n-n2,n,status,kappa,b[n]);      if(debug>1){	// e=[Phi(x)]_b-Phi(x)	csolve_newton_e_norm(e[n],m,y,x,fF,fJ,b[n]*4);	// c=b-tau+log2(e)	rlog2_r(c[n],e[n]); rsub_rd(c[n],c[n],tau[n]); radd_rd(c[n],c[n],b[n]);	// 2^(-b+tau+kappa)	csolve_newton_emax(em[n],b[n],kappa,tau[n]);	// gamma*eta/(8*beta)	csolve_newton_e_border(eb[n],eta[n],beta[n],gamma_exp);	mpfr_printf("e=%7.0Re ",e[n]);	if(ris_nan(e[n]) || ris_nan(em[n])){ printf("  "); }else if(le_rr(e[n],em[n])){ printf("< "); }else{ print_yellow(); printf("> "); print_reset(); }	mpfr_printf("em=%7.0Re ",em[n]);	if(ris_nan(e[n]) || ris_nan(eb[n])){ printf("  "); }else if(le_rr(e[n],eb[n])){ printf("e<"); }else{ print_yellow(); printf("e>"); print_reset(); }	mpfr_printf("eb=%7.0Re ",eb[n]);	mpfr_printf("c=%5.1Rf ",c[n]);	// x	mpfr_printf("|x|=%5.0Re=2^%-2d ",x_norm[n],tau[n]);	// krawczyk	cvec_absc_cvec(m,dx,dx); cvec_mul_cvec_dscalar(m,dx,dx,2);	info=csolve_krawczyk(m,dx,x,fF,0);	if(info){ rset_nan(Ek[n]); }else{ rmax_abs_cvec(Ek[n],m,dx); }	mpfr_printf("Ek=%7.0Re ",Ek[n]);	// true error	if(xt!=NULL){	  rmax_abs_sub_cvec_cvec(Et[n],m,x,xt);	  mpfr_printf("Et=%7.0Re",Et[n]);	  rdiv_2exp(Et[n],Et[n],1);	  if(le_rr(Et[n],Et[n])){ printf("(O) "); }else{ printf("(X) "); }	  rmul_2exp(Et[n],Et[n],1);	}      }      mpfr_printf("|F|=%7.0Re ",F_norm[n]);      mpfr_printf("η=%7.0Re ",eta[n]);      if(n>=1){	mpfr_printf("n=%3d μ=%8.0Re β=%8.0Re ",n-1,mu[n-1],beta[n-1]);	//	if(debug>1 && !nofit){ for(i=1; i<l; i++){ mpfr_printf("%.0Re ",beta[n-i-1]); } }	mpfr_printf("θ=%5.0Re (θ)=%5.0Re",theta[n-1],theta0[n-1]);	if     (ris_nan(theta[n-1]) || ris_nan(theta0[n-1])){ printf("    "); }	else if(le_rr(theta0[n-1],theta[n-1])){ printf("(O) "); }	else                                { printf("(X) "); }	if(!nofit){ printf("γ=2^%d ",gamma_exp); }      }      print_reset();      printf("\n");    }    // update x    if(status==' ' || status=='o'){      // restore x to backup      cmat_cols_rotate_right(m,kmax,X,m); cvec_clone_cvec(m,&COL(X,0,m),x); if(++k>kmax){ k=kmax; }      // x=y      cvec_clone_cvec(m,x,y);      // next step      n++;      // newest step      if(n>n2){ n2=n; }    }else if(status=='^'){      // redo same step    }else if(status=='x'){      // restore x from backup      if(k<=0){ ERROR_AT; printf("No backup.\n"); exit(0); }      cvec_clone_cvec(m,x,&COL(X,0,m)); cmat_cols_rotate_left(m,kmax,X,m); --k;      // back step      n--;      // set previous precision      kappa+=kappa_gain;    }    // next trial    t++;    // continue, or break loop  }while(status==' ' || status=='o' || status=='x' || status=='^');  // restore x from backup  while(n>n2){    if(k<=0){ ERROR_AT; printf("No backup.\n"); exit(0); }    cvec_clone_cvec(m,x,&COL(X,0,m)); cmat_cols_rotate_left(m,kmax,X,m); --k;    n--;  }  // set return value  ret=b[n];  if(debug>0){    mpfr_printf("[%s] return x%d, n0=%d, n1=%d, n2=%d, κ=%d, ret=%d\n",name,n,n0,n1,n2,kappa,ret);    for(n=n0; n<=n2; n++){      mpfr_printf("[%s] n=%3d b=%5d ",name,n,b[n]);      if(debug>1){ mpfr_printf("|x|=%6.0Re ",x_norm[n]); }      mpfr_printf("|F|=%7.0Re η=%7.0Re ",F_norm[n],eta[n]);      if(n>=1 && n-1>=n0){	mpfr_printf("   n=%3d μ=%8.0Re β=%8.0Re θ=%5.0Re ",n-1,mu[n-1],beta[n-1],theta[n-1]);      }      if(n>n1){	mpfr_printf("(θ)=%5.0Re",theta0[n-1]);	if(ris_number(theta[n-1]) && ris_number(theta0[n-1]) && le_rr(theta0[n-1],theta[n-1])){ printf("(O) "); }else{ printf("(X) "); }      }      printf("\n");    }  }  // done  IVF(b); IVF(tau);  CVF(F,m); CVF(y,m); CVF(dx,m); CMF(J,m,m); CMF(X,m,kmax);  RF(theta_min);  RVF(eta,nmax); RVF(mu,nmax); RVF(beta,nmax); RVF(theta,nmax); RVF(theta0,nmax);   RVF(F_norm,nmax); RVF(x_norm,nmax); RVF(Ek,nmax); RVF(Et,nmax); RVF(eb,nmax); RVF(em,nmax); RVF(e,nmax); RVF(c,nmax);  fJ=func_del(fJ);  set_default_prec(prec);  return ret;}////////////////////////////////void csolve_newton_map(int m, cmulti **y, cmulti **x, func_t *fF, func_t *fJ){  int info;  cmulti **F=NULL,**J=NULL;  // allocate  CVA(F,m); CMA(J,m,m);  // F=F(x)  cvec_func_list(m,F,fF,m,x);  // J=J(x)  cmat_func_list2(m,m,J,m,fJ,m,x);  // F=J\F  csolve(m,1,F,m,J,m,&info);  // if J is singular, or not  if(info){ cvec_set_nan(m,y); }  else{    // y=x-J\F    cvec_sub_cvec_cvec(m,y,x,F);  }  // free  CVF(F,m); CMF(J,m,m);  return;}void csolve_newton_e_norm(rmulti *e_norm, int m, cmulti **y0, cmulti **x, func_t *fF, func_t *fJ, int prec){  int prec0,info;  cmulti **y=NULL,**F=NULL,**J=NULL;  // backup prec  prec0=get_default_prec();  // set prec  set_default_prec(prec);  // allocate  CVA(F,m); CVA(y,m); CMA(J,m,m);  // F=F(x)  cvec_func_list(m,F,fF,m,x);  // J=J(x)  cmat_func_list2(m,m,J,m,fJ,m,x);  // F=J\F  csolve(m,1,F,m,J,m,&info);  // if J is singular, or not  if(info){ rset_nan(e_norm); }  else{    // y=x-J\F    cvec_sub_cvec_cvec(m,y,x,F);    // e_norm=max(abs(y-y0))    rmax_abs_sub_cvec_cvec(e_norm,m,y,y0);  }  // free  CVF(F,m); CVF(y,m); CMF(J,m,m);  // set backup prec  set_default_prec(prec0);  return;}// gamma*eta_{n}/(8*beta_{n})void csolve_newton_e_border(rmulti *border, rmulti *eta, rmulti *beta, int gamma_exp){  if(!(ris_number(eta) && le_rd(eta,1))){ rset_nan(border); return; }  if(!(ris_number(beta) && ge_rd(beta,1))){ rset_nan(border); return; }  rset_d(border,1);  rmul_2exp(border,border,gamma_exp);  rmul_rr(border,border,eta);  rdiv_2exp(border,border,3);  rdiv_rr(border,border,beta);}// 2^(-b+tau+kappa)void csolve_newton_emax(rmulti *border, int b, int kappa, int tau){  rset_d(border,1);  rmul_2exp(border,border,-b+tau+kappa);}//////////////////////////////////////////////////////////// ||e_{n}|| <= 2^(-b+tau+kappa) <= gamma*theta_{n-1}*eta_{n-1}/(8*beta_{n}*beta_{n-1})int csolve_newton_prec_from_beta(rmulti *eta0, rmulti *beta0, rmulti *beta1, rmulti *theta0, int gamma_exp, int kappa, int tau){  int prec=0;     if(!(ris_number(eta0) && le_rd(eta0,1))){ return prec; }  if(!(ris_number(theta0) && le_rd(theta0,1))){ return prec; }  if(!(ris_number(beta0) && ge_rd(beta0,1))){ return prec; }  if(!(ris_number(beta1) && ge_rd(beta1,1))){ return prec; }  prec=kappa+tau-(gamma_exp+(rget_exp(theta0)-1)+(rget_exp(eta0)-1)-3-rget_exp(beta0)-rget_exp(beta1));  return prec;}// ||e_{n}|| <= 2^(-b+tau+kappa) <= gamma*eta_{n-1}^7/(2*eta_{n-2}^6)int csolve_newton_prec_from_eta(rmulti *eta0, rmulti *eta1, int gamma_exp, int kappa, int tau){  int prec=0;  if(!(ris_number(eta0) && le_rd(eta0,1) && ris_number(eta1) && le_rd(eta1,1))){ return prec; }  prec=kappa+tau-(gamma_exp+7*(rget_exp(eta1)-1)-1-6*(rget_exp(eta0)));  return prec;}// ||e_{n}|| <= 2^(-b+tau+kappa) <= gamma*eta_{n-1}/(128*mu_{n-2}^6)int csolve_newton_prec_from_mu(rmulti *mu0, rmulti *eta0, int gamma_exp, int kappa, int tau){  int prec=0;     rmulti *eps=NULL;  if(!(ris_number(mu0) && ge_rd(mu0,1) && ris_number(eta0) && le_rd(eta0,1))){ return prec; }  RA(eps);  rpow_r(eps,mu0,6); rmul_2exp(eps,eps,7); rdiv_rr(eps,eta0,eps);    prec=kappa+tau-(rget_exp(eps)-1+gamma_exp);  RF(eps);  return prec;}//////////////////////////////////////////////////////////void csolve_newton_theta(int n, rmulti **theta, rmulti *theta_min, rmulti **mu, rmulti **beta){  int i;  for(i=0; i<n; i++){    rdiv_rr(theta[i],beta[i],mu[i]);    if(lt_rr(theta[i],theta_min)){ rclone_r(theta_min,theta[i]); }  }}void csolve_newton_theta_estimate(rmulti *theta_est, rmulti *theta_min){  //rpow_s(theta_est,theta_min,1);                                   // theta_est=(theta_min)  //rpow_s(theta_est,theta_min,2);                                   // theta_est=(theta_min)^2  //rpow_si(theta_est,theta_min,2); rdiv_2exp(theta_est,theta_est,1); // theta_est=(theta_min)^2/2  rpow_r(theta_est,theta_min,2); rdiv_2exp(theta_est,theta_est,2); // theta_est=(theta_min)^2/4  //rpow_si(theta_est,theta_min,2); rdiv_2exp(theta_est,theta_est,3); // theta_est=(theta_min)^2/8}//////////////////////////////////////////////////////////int csolve_newton_gamma(rmulti *beta, rmulti *mu){  rmulti *gamma=NULL;  int gamma_exp=0;  RA(gamma);  rdiv_rr(gamma,beta,mu); rsub_rd(gamma,gamma,1); rneg_r(gamma,gamma); // gamma=1-(beta/mu)  gamma_exp=rget_exp(gamma)-1;  rset_d(gamma,1);  rmul_2exp(gamma,gamma,gamma_exp);  RF(gamma);  return gamma_exp;}//////////////////////////////////////////////////////////// 2*||x1-x0||<=epsint csolve_newton_condition_done(int m, cmulti **x0, cmulti **x1, rmulti *eps){  int value=0;  rmulti *a=NULL,*b=NULL;  if(!ris_number(eps)){ return value; }  if(cvec_has_nan(m,x0)){ return value; }  if(cvec_has_nan(m,x1)){ return value; }  RA(a); RA(b);  // eps^2-4*||x1-x0||^2>=0  rmul_rr(a,eps,eps);  rmax_pow2_abs_sub_cvec_cvec(b,m,x1,x0); rmul_2exp(b,b,2);  rsub_rr(a,a,b);  if(ge_rd(a,0)){ value=1; }else{ value=0; }  RF(a); RF(b);  return value;}// ||x2-x1||/||x1-x0||<=1/(2*beta)int csolve_newton_condition_conv(int m, cmulti **x0, cmulti **x1, cmulti **x2, rmulti *beta){  int value=0;  rmulti *a=NULL,*b=NULL;  if(!ris_number(beta)){ return value; }  if(cvec_has_nan(m,x0)){ return value; }  if(cvec_has_nan(m,x1)){ return value; }  if(cvec_has_nan(m,x2)){ return value; }  RA(a); RA(b);  // ||x1-x0||^2-(2*beta)^2*||x2-x1||^2>=0  rmax_pow2_abs_sub_cvec_cvec(a,m,x1,x0);  rmax_pow2_abs_sub_cvec_cvec(b,m,x2,x1);  rmul_rr(b,b,beta); rmul_rr(b,b,beta); rmul_2exp(b,b,2);  rsub_rr(a,a,b);  if(ge_rd(a,0)){ value=1; }else{ value=0; }  RF(a); RF(b);  return value;}//////////////////////////////////////////////////////////// beta[i]=2*beta[i-1]^2-1void csolve_newton_beta_by_recur(int n, rmulti **beta){  int i;  for(i=1; i<n; i++){ rmul_rr(beta[i],beta[i-1],beta[i-1]); rmul_rd(beta[i],beta[i],2); radd_rd(beta[i],beta[i],-1); }}int csolve_newton_beta_from_mu(int n, rmulti **beta, rmulti **mu, int debug){  char *name="csolave_newton_get_beta_from_mu";  int i=0,imax=1000,done=0,value=1;  double beta_min=1.0,eps=1e-15;  //  double theta_border=1.1;  rmulti *left=NULL,*right=NULL,*delta=NULL,*theta=NULL;  // mu>=1?  if(rvec_has_nan(n,mu) || !rvec_ge_d2(n,mu,beta_min)){    rvec_set_nan(n,beta);    if(debug>0){ printf("[%s] return 1\n",name); }    return value;  }  // begein with [1,mu0], beta0=mu0  RA(left); RA(right); RA(delta); RA(theta);  rset_d(left,beta_min); rset_r(right,mu[0]); rset_r(beta[0],right);  // loop  do{    // compute    csolve_newton_beta_by_recur(n,beta);                                        // set beta with beta0    if(rvec_ge(n,mu,beta)){ rset_r(left,beta[0]); }else{ rset_r(right,beta[0]); } // shrink    rsub_rr(delta,right,left); rdiv_rr(delta,delta,right);                            // delta=(right-left)/right    rmax_div_abs_rvec_rvec(theta,n,mu,beta);                                          // theta=max(mu./beta)    if(debug>0){ mpfr_printf("[%s] i=%d beta=%.3Re left=%.3Re right=%.3Re delta=%.3Re theta=%.3Re\n",name,i,beta[0],left,right,delta,theta); }    // next    i++;    if(i>=imax){ done=-1;}        else if(le_rd(delta,eps)){ done=1; }    else{ radd_rr(beta[0],left,right); rmul_rd(beta[0],beta[0],0.5); } // beta[0]=(left+right)/2  }while(!done);  // convert beta to integers  rmul_rd(beta[0],beta[0],0.9);  rmul_rd(beta[0],beta[0],100); rfloor_r(beta[0],beta[0]); rdiv_rd(beta[0],beta[0],100);  csolve_newton_beta_by_recur(n,beta);  value=0;  // done  if(debug>0){ printf("[%s] return 0\n",name); }  RF(left); RF(right); RF(delta); RF(theta);  return value;}////////////////////////////////////////////////////////////////////////////////////////////////////////////////////void csolve_func_residual(int m, rmulti *norm, cmulti **F, cmulti **x, func_t *fF){  cmulti **F0=NULL,**F1=NULL;  rmulti *norm0=NULL,*norm1=NULL;  RA(norm0); RA(norm1); CVA(F0,m); CVA(F1,m);  // F=F(x)  cvec_func_list(m,F,fF,m,x);  // [F0,F1]=F(x)  icvec_func_list(m,F0,F1,fF,m,x,x);  // |F|  rmax_abs_cvec(norm,m,F);  rmax_abs_cvec(norm0,m,F0);  rmax_abs_cvec(norm1,m,F1);  // check  if(gt_rr(norm1,norm)){ rswap(norm1,norm); cvec_swap(m,F,F1); }  if(gt_rr(norm0,norm)){ rswap(norm0,norm); cvec_swap(m,F,F0); }  // done  RF(norm0); RF(norm1); CVF(F0,m); CVF(F1,m);}////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Input: m,x,fF,step_max// Output: xint csolve_newton(int m, cmulti **x, func_t *fF, int step_max, int debug){  char *name="csolve_newton",status=' ';  int info,n,ret;  func_t *fJ=NULL;  cmulti **F=NULL,**J=NULL,**e=NULL;  rmulti *eta=NULL,*eta_pre=NULL,*mu=NULL,*b=NULL,*a=NULL,*emax=NULL;  // init  CVA(F,m); CMA(J,m,m); RA(eta); RA(eta_pre); RA(mu); RA(b); RA(a);  // begin  if(step_max<0){ step_max=100; }  fJ=func_grad(func_retain(fF),func_var1_list(m));  if(debug>0){    mpfr_printf("[%s] step_max=%d\n",name,step_max);    printf("[%s] F(x)=",name); func_print(fF); printf("\n");    printf("[%s] F'(x)=",name); func_print(fJ); printf("\n");  }  // compute  if(cvec_has_nan(m,x)){ cvec_set_rand(m,x,2,-1); }  n=0; rset_d(eta_pre,0);  if(debug>0){ mpfr_printf("[%s] begin x[%d]\n",name,n,n); }  do{    // a=|x|    rmax_abs_cvec(a,m,x);    // F=F(x)    cvec_func_list(m,F,fF,m,x);    // b=|F|    rmax_abs_cvec(b,m,F);    // exactly F=0?    if(eq_rd(b,0)){ csolve_func_residual(m,b,F,x,fF); }    // if F=0, then...    if(eq_rd(b,0)){ status='='; }    else{      // J=J(x)      cmat_func_list2(m,m,J,m,fJ,m,x);      // F=J\F      csolve(m,1,F,m,J,m,&info);      if(info){	// set status	status='J';	rset_nan(eta); rset_nan(mu);      }else{	// eta=|J\F|	rmax_abs_cvec(eta,m,F);	// mu=eta/eta_pre	rdiv_rr(mu,eta,eta_pre);	// set status	if     (n>=step_max)                   { status='/'; }	else if(status==' ' && le_rd(mu,1e-2)){ status='o'; }	else if(status=='o' && ge_rd(mu,1))   { status='x'; }      }    }    if(debug>0){      CVA(e,m); RA(emax);      info=csolve_krawczyk(m,e,x,fF,0);      rmax_abs_cvec(emax,m,e);      if(info){ mpfr_printf("[%s] n=%d [%c]         |x[%d]|=%.1Re |F(x[%d])|=%.1Re |x[%d]-x[%d]|=%.1Re mu=%.1Re\n",name,n,status,n,a,n,b,n+1,n,eta,mu); }      else    {	mpfr_printf("[%s] n=%d [%c] e=%.0Re |x[%d]|=%.1Re |F(x[%d])|=%.1Re |x[%d]-x[%d]|=%.1Re mu=%.1Re\n",name,n,status,emax,n,a,n,b,n+1,n,eta,mu); }      CVF(e,m); RF(emax);    }    // update x    if(status==' ' || status=='o'){      // x=x-J\F      cvec_sub_cvec_cvec(m,x,x,F);      // next      n++;      rswap(eta,eta_pre);    }  }while(status==' ' || status=='o');  // value  if     (status=='/' || status=='=' || status=='x'){ ret=0; }  else if(status=='o' || status==' ' || status=='J'){ ret=1; }  else                                              { ret=1; }  if(debug>0){ mpfr_printf("[%s] return x[%d] ret=%d\n",name,n,ret); }  // done  CVF(F,m); CMF(J,m,m); RF(eta); RF(eta_pre); RF(mu); RF(b); RF(a);  fJ=func_del(fJ);  return ret;}////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// Input: x,dF// Output: e// Return: 0 if success, 1 if failint csolve_krawczyk(int m, cmulti **e, cmulti **x, func_t *fF, int debug){  int info,ret=1;  func_t *fJ=NULL;  cmulti **L=NULL,**L0=NULL,**L1=NULL,**R=NULL,**M0=NULL,**M1=NULL;  cmulti **F=NULL,**F0=NULL,**F1=NULL;  cmulti **X0=NULL,**X1=NULL,**T0=NULL,**T1=NULL;  cmulti **r0=NULL,**r1=NULL,**H0=NULL,**H1=NULL;  // begin  fJ=func_grad(func_retain(fF),func_var1_list(m));  if(debug>1){ printf("fJ="); func_print(fJ); printf("\n"); }  CMA(L,m,m); CMA(L0,m,m); CMA(L1,m,m); CMA(R,m,m); CMA(M0,m,m); CMA(M1,m,m);  CVA(F,m); CVA(F0,m); CVA(F1,m); CVA(X0,m); CVA(X1,m);  CVA(T0,m); CVA(T1,m); CVA(r0,m); CVA(r1,m); CVA(H0,m); CVA(H1,m);  // compute  // F=F(x)  cvec_func_list(m,F,fF,m,x); if(debug>0){ cvec_print(m,F,"F=",'e',1); }  // L=F'(x)  cmat_func_list2(m,m,L,m,fJ,m,x);  // R=inv(L)  cmat_set_eye(m,m,R,m); csolve(m,m,R,m,L,m,&info);  // e=abs(R*F)  if(cvec_has_nan(m,e)){    cvec_mul_cmat_cvec(m,m,e,R,m,F);    cvec_absc_cvec(m,e,e);    cvec_mul_cvec_dscalar(m,e,e,2);  }  // [F0,F1]=F(x)  icvec_func_list(m,F0,F1,fF,m,x,x); if(debug>0){ icvec_print(m,F0,F1,"[F]=",'e',1); }  // [X0,X1]=[-e,e]  icvec_pm_cvec(m,X0,X1,e); if(debug>0){ icvec_print(m,X0,X1,"[X]=",'e',1); }  // [T0,T1]=[x-e,x+e]  icvec_add_cvec_cvec(m,T0,T1,X0,X1,x,x); if(debug>1){ icvec_print(m,T0,T1,"[T]=",'f',20); }  // [L0,L1]=F'([T0,T1])  icmat_func_list2(m,m,L0,L1,m,fJ,m,T0,T1);  // [M0,M1]=I-R*[L0,L1]  cmat_set_eye(m,m,M0,m); cmat_set_eye(m,m,M1,m);  icmat_sub_prod(m,m,m,M0,m,M1,m,R,m,R,m,L0,m,L1,m);  if(debug>1){ icmat_print(m,m,M0,m,M1,m,"[M]=",'e',1); }  // H=-R*[F0,F1]+[M0,M1]*X  cvec_set_zeros(m,H0); cvec_set_zeros(m,H1);  icvec_sub_lintr(m,m,H0,H1,R,m,R,m,F0,F1);  icvec_add_lintr(m,m,H0,H1,M0,m,M1,m,X0,X1);    if(debug>0){ icvec_print(m,H0,H1,"[H]=",'e',1); }  // check X0<=H0 and H1<=X1  if(!cvec_has_nan(m,X0) && !cvec_has_nan(m,X1) &&     !cvec_has_nan(m,H0) && !cvec_has_nan(m,H1) &&     cvec_lec(m,X0,H0) && cvec_lec(m,H1,X1)){ ret=0; }  else                                      { ret=1; }  // done  CMF(L,m,m); CMF(L0,m,m); CMF(L1,m,m); CMF(R,m,m); CMF(M0,m,m); CMF(M1,m,m);  CVF(F,m); CVF(F0,m); CVF(F1,m); CVF(X0,m); CVF(X1,m);  CVF(T0,m); CVF(T1,m); CVF(r0,m); CVF(r1,m); CVF(H0,m); CVF(H1,m);  fJ=func_del(fJ);  return ret;}//EOF